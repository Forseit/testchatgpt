from __future__ import annotations

import json
import subprocess
import sys
from pathlib import Path
from typing import Sequence

from .cases import TestCase

__all__ = ["ensure_pytest_available", "generate_pytest_file"]


def ensure_pytest_available() -> None:
    """Ensure that ``pytest`` is importable.

    The function attempts to import :mod:`pytest` and installs it via ``pip`` if
    necessary.  Installation output is forwarded to the console.
    """

    try:
        import pytest  # noqa: F401
    except ModuleNotFoundError:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pytest"])


def _case_to_dict(case: TestCase) -> dict[str, str | None]:
    return {
        "name": case.label,
        "input": case.input_data,
        "expected": case.expected_output,
    }


def generate_pytest_file(
    test_cases: Sequence[TestCase],
    script_path: Path,
    target_path: Path,
    *,
    timeout: float | None = None,
) -> Path:
    """Write a pytest module that executes *script_path* for each test case.

    Parameters
    ----------
    test_cases:
        Iterable of parsed test cases.
    script_path:
        Path to the script under test.
    target_path:
        Destination for the generated ``pytest`` file.
    timeout:
        Optional timeout (in seconds) passed to ``subprocess.run`` within the
        generated tests.
    """

    target_path.parent.mkdir(parents=True, exist_ok=True)
    normalized_script = script_path.resolve()

    payload = {
        "cases": [_case_to_dict(case) for case in test_cases],
        "timeout": timeout,
    }

    json_blob = json.dumps(payload, ensure_ascii=False, indent=4)
    escaped_json = json_blob.replace("\\", "\\\\").replace('"""', '\\"\\"\\"')
    script_literal = str(normalized_script).replace("\\", "\\\\")

    module_source = "\n".join(
        [
            '"""Auto-generated by main.py – do not edit manually."""',
            "",
            "from __future__ import annotations",
            "",
            "import json",
            "import subprocess",
            "import sys",
            "import time",
            "from pathlib import Path",
            "",
            "import pytest",
            "",
            f"_DATA = json.loads(\"\"\"{escaped_json}\"\"\")",
            f"_SCRIPT = Path(r\"{script_literal}\")",
            "_TIMEOUT = _DATA[\"timeout\"]",
            "_TEST_CASES = _DATA[\"cases\"]",
            "",
            "",
            "def _run_case(case: dict[str, str | None]) -> tuple[int, str, str, float]:",
            "    start = time.perf_counter()",
            "    completed = subprocess.run(",
            "        [sys.executable, str(_SCRIPT)],",
            "        input=case[\"input\"],",
            "        text=True,",
            "        capture_output=True,",
            "        timeout=_TIMEOUT,",
            "        check=False,",
            "    )",
            "    elapsed = time.perf_counter() - start",
            "    stdout = completed.stdout",
            "    stderr = completed.stderr",
            "    return completed.returncode, stdout, stderr, elapsed",
            "",
            "",
            "@pytest.mark.parametrize(\"case\", _TEST_CASES, ids=lambda case: case[\"name\"])",
            "def test_generated(case) -> None:",
            "    returncode, stdout, stderr, _ = _run_case(case)",
            "    expected = case.get(\"expected\")",
            "    if returncode != 0:",
            "        pytest.fail(",
            "            f\"Процесс завершился с кодом {returncode}.\\\\nSTDERR: {stderr.strip()}\"",
            "        )",
            "    if expected is not None:",
            "        assert stdout == expected, (",
            "            \"Вывод не совпадает с ожидаемым.\\\\n\"",
            "            f\"Ожидалось: {expected!r}\\\\n\"",
            "            f\"Получено: {stdout!r}\"",
            "        )",
        ]
    )

    target_path.write_text(module_source, encoding="utf-8")
    return target_path
